#Developer checklist / guideline

Документ служит нескольким целям:

 - Выработка стандартов написания кода в компании
 - Закрепление “хороших” практик и приемов написания и структурирования кода
 - Чеклист, помогающий проверить качество собственного кода
 - Чеклист, помогающий проводить ревью чужого кода

Некоторые требования носят рекомендательный характер, и некоторыми из них можно пренебречь. Однако в этом случае нужно быть готовым ответить, почему было решено сделать именно так, презумпция невиновности не работает.

##Чеклист по организации кода
Чеклист предназначен для быстрого и удобного поиска того или иного требования, предъявляемого к коду. Все ссылки и примеры, поясняющие пункты чеклиста, вынесены отдельно.

###Общие правила оформления и структуры кода
 - Соответствие кода принятым стандартам оформления кода; [подробно](#Стандарты-оформления-кода)
 - Комментарии к классам, методам, сложным участкам кода; [подробно](#Комментирование-кода)
 - Неиспользуемый код (переменные, методы, классы) должен быть удален, т.к. затрудняет понимание структуры приложения;
 - Закомментированный код должен быть удален. Все предыдущие ревизии хранятся в системе контроля версий, так что ничто не будет потеряно;
 - Методы должны содержать не больше 50 строк за редким исключением. Если метод слишком длинный, это говорит о его сложности или плохой структуре, его стоит разбить на несколько методов с ясными именами;
 - Более 3 вложенных конструкций if нежелательно. Лучше отрефакторить этот код или хотя бы вынести вложенную логику в отдельный метод;
 - Для работы со временем и датами лучше использовать новые возможности PHP по работе со временем в объектно-ориентированном стиле: `DateTime`, `DateInterval`, `DatePeriod`;

###Безопасность
 - Все входящие данные должны проверяться на корректность. В особенности это касается сохранения моделей;
 - Ошибки валидации всегда должны выводиться пользователю;
 - Все значения полей таблиц, подставляемые в SQL-запрос, должны экранироваться; [подробно](#Экранирование-данных-запроса)
 - Все имена полей или таблиц, подставляемые в SQL-запрос, должны проверяться по белому списку допустимых значений; [подробно](#Фильтр-по-белому-списку)

###Имена классов, переменных, методов, констант
 - Имена всех идентификаторов должны ясно и четко описывать их предназначение;
 - Имена идентификаторов должны быть написаны на грамотном английском языке;
 - Недопустимо использование транслита в именах идентификаторов;
 - Мягкий предел длины идентификаторов – 30 символов;

###Магические строки и числа
 - В коде не должны использоваться “магические” строки и константы: любое число или строка, имеющие специальное значение, должны быть вынесены в зависимости от их предназначения, в константы класса, общие константы программы или в настройки проекта;
 - Статическая информация, имеющая отношение к проекту (пути к директориям, размеры изображений, e-mail'ы, ключи Google Maps и т.д.) должны выноситься в конфиг приложения; [подробно](#Настройки-проекта)
 - Сообщения об ошибках валидации, сообщения в бросаемых исключениях, специальные строки или числа, имеющие отношение к классу, должны выноситься в константы уровня класса; [подробно](#Константы-класса)
 - Исключения: можно пощадить числа 0 и 1 (ввиду того, чтобы они используются чрезвычайно часто), когда они используются в понятном контексте;
 - Нельзя использовать статические ID для получения записей из БД; [подробно](#Статические-id-в-sql-запросах)
 - Нельзя полагаться на то, что проект будет привязан к определенному домену, или даже будет находиться в корневой директории вебсервера; [подробно](#Использование-baseurl)

###Обработка ошибок и предупреждений PHP
 - Уровень `error_reporting` во всех окружениях: development, testing, production, обязательно должен быть установлен в `E_ALL`;
 - Нельзя использовать оператор подавления ошибок `@`. Все ошибки и нотисы должны быть видны в процессе разработки;
 - При разработке и тестировании все ошибки обязательно должны отображаться пользователю (`display_errors = true`)
 - В production окружении все ошибки обязательно должны быть скрыты от пользователя (`display_errors = false`), однако должны записываться в лог приложения;

###Системы контроля версий
 - Сообщения в коммитах должны быть написаны на английском и содержать внятное описание того, какие изменения содержит данный коммит. “Fixed several bugs” - не подходит;
 - Директории, содержащие динамически создаваемые данные, должны находиться в репозитории пустыми, и для них должны быть определены соответствующие правила игнора. Для SVN это может быть общий файл `.svnignore`. Git не умеет хранить пустые директории, поэтому в каждом таком каталоге должен содержаться отдельный файл `.gitignore`

###MVC
 - Недопустимо присутствие кода SQL запросов в контроллере;
 - Недопустимо присутствие HTML разметки в контроллере;
 - Недопустимо наличие бизнес-логики в представлениях;
 - Не рекомендуется присутствие сложного PHP кода в представлениях;
 - Не рекомендуется присутствие JavaScript кода в контроллерах;
 - Минимальное количество inline JavaScript кода в представлениях;


###JavaScript
 - Стандарты оформления кода – те же, что и в PHP;
 - Обязательно ставить точку с запятой после операторов;
 - Использовать директиву “use strict”. Она переводит интерпретатор в т.н. “строгий режим”, который накладывает на синтаксис JavaScript некоторые ограничения, которых ему так не хватает;
 - При передаче данных с помощью AJAX основным форматом используется JSON;
Использовать $.ajax() с определенными коллбэками success и error вместо $.get(), $.post() etc.
 - Использовать $.on() вместо $.delegate(), $.bind() и $.live();
 - Для больших сложных одностраничных приложений на JavaScript используем MV* фреймворки, предпочтительно Backbone.js или Knockout.js, одного jQuery для этого недостаточно;

Ссылки:
John Resig - ECMAScript 5 Strict Mode, JSON, and More
Habrahabr: JavaScript Strict Mode

###Общие принципы проектирования и конструирования хорошего кода
 - [KISS](#keep-it-simple-stupid)
 - [DRY](#dont-repeat-yourself)
 - [YAGNI](#you-aint-gonna-need-it)


###Yii
… …

##Пояснения пунктов чеклиста

###Стандарты оформления кода
Код должен соответствовать стандартам кодирования PSR-2, который является попыткой ввести всеобщий стандарт кодирования для различных фреймворков, CMS и библиотек написанных на PHP. Существует три стандарта PSR с номерами от 0 до 2, каждый из которых требует выполнения предыдущего, т.е. использование стандарта PSR-2 предполагает также соответствие кода стандартам PSR-1 и PSR-0.

Вкратце:

 - Имена классов: UpperCamelCase; каждый символ подчеркивания в имени класса преобразовывается в DIRECTORY_SEPARATOR при автозагрузке файла класса;
 - Имена констант: ALL_CAPS через символ подчеркивания;
 - Имена методов классов и функций: lowerCamelCase
 - UTF-8 для всех файлов исходного кода
 - Отступы – 4 пробела
 - Нет жесткого лимита для длины строк; мягкий лимит – 120 символов;
 - Расположение фигурных скобок в стиле Кернигана-Ричи:
 - В определении функции, класса или метода класса открывающая скобка располагается на новой строке без дополнительного отступа, закрывающая скобка – на следующей строке после окончания блока кода.
 - Остальные открывающие фигурные скобки должны располагаться на той же строке, что и элемент синтаксиса, к которому она относится.
 - Для всех методов и атрибутов класса обязательно указывать область видимости (public, private, protected)
 - Все ключевые слова в нижнем регистре (true, false, null и т.д.)
 - Не использовать нижнее подчеркивание в начале имен приватных и защищенных атрибутов класса
 - Стандарт не описывает правила именования обычных переменных и атрибутов класса, в этом опираемся на стандарты PEAR, который предписывает использовать camelCase.
 - То же касается ключей ассоциативных массивов.

Исключения: если фреймворк использует автозагрузчик классов несовместимый с PSR-0, можно использовать именование классов, наиболее удобное для использования в этом фреймворке.
При генерации моделей Yii генерирует атрибуты модели в соответствии с именами полей соответствующей таблицы БД. Как правило, поля таблиц именуются как under_score.

Могут быть и другие исключения, продиктованные удобством использования того или иного фреймворка, или стандартами кодирования унаследованного кода. Обязательное условие при этом – недопустимо использовать разные стандарты кодирования в разных местах одного и того же проекта. Гораздо лучше последовательно придерживаться пусть не общепринятых, но постоянных стандартов, чем не использовать их вообще.

Ссылки:
[PSR Standarts](https://github.com/php-fig/fig-standards/tree/master/accepted)
[PEAR Standarts](http://pear.php.net/manual/en/standards.php)

###Комментирование кода
 - Комментирование кода должно выполняться по стандартам phpDocumentor.
 - Комментарий уровня класса: краткое описание назначения класса, его взаимодействий. Если необходимо – краткие примеры использования класса.
 - Комментарии уровня метода: краткое описание предназначения метода, его входных и выходных параметров, возможные исключения которые бросает метод. Если необходимо – примеры использования метода.
 - Комментарии кода: необходимо комментировать неочевидный, запутанный или сложный  код. Однако лучше всего каждый такой кусок кода выносить в отдельный метод с ясным и понятным названием и соответствующими комментариями уровня метода класса.
 - В комментариях обязательно нужно указывать сложные неочевидные или неявные взаимодействия. Например, behaviours в yii, использование магических методов.
 - Не нужно, и даже вредно выступать в качестве капитана очевидности: в комментариях не нужно переписывать то, что и так понятно при чтении кода. Хороший комментарий должен указывать на сложные или скрытые для понимания вещи, например, описывать почему выбран именно такой метод решения задачи, схему взаимодействия объектов.

В качестве задания “на пять с плюсом” можно с помощью phpDocumentor'a автоматически сгенерировать документацию на основании своего кода, и проверить, можно ли по этой документации понять структуру классов и их взаимодействий.

Ссылки:
[phpDocumentor](http://www.phpdoc.org/)

###Обработка данных в SQL запросах
Любые данные, передающиеся в SQL-запрос извне, в обязательном порядке должны пройти проверку перед вставкой в SQL, для того чтобы исключить возможность SQL injection.

####Экранирование данных запроса

При работе с базой данных нужно пользоваться штатными средствами фреймворка по работе с базой. Как правило, все фреймворки предоставляют свою обертку над библиотекой PDO, или замену ей. Например, в Yii для построения чистых SQL запросов используются классы DAO, которые являются надстройкой над PDO, они автоматически производят экранирование всех данных передающихся в запрос.
Если проект не использует никакой фреймворк, нужно использовать библиотеку PDO, а не низкоуровневые драйверы  php_mysql, php_pgsql и т. д.

```php
// неправильно
$db->query("SELECT * FROM users WHERE userId = $userId");

// правильно, поскольку нет подстановки значения переменной
$result = $db->query('SELECT * FROM articles WHERE status='active'');

// правильно, явное экранирование значения переменной
$escapedUserId = $db->quote($userId);
$result = $db->query('SELECT * FROM users WHERE userId = '.$escapedUserId);

// использование плейсхолдеров и подготовленных выражений для экранирования
// наилучший способ, хотя работает медленнее предыдущего
$query = $db->prepare('SELECT * FROM users WHERE userId = :userId');
$result = $query->execute(array(':userId' => $userId));
```

####Фильтр по белому списку

Если фреймворки и библиотеки для работы с БД предлагают решение проблемы экранирования данных, то при запросах в которых динамически выбираются те или иные поля таблиц (или даже сами таблицы), нужно вручную выполнять проверку входных данных по белому списку:

```php
// неправильно
$result = $db->query("SELECT * FROM articles ORDER BY $sortOrder $sortDirection");

// неправильно, от экранирования в случае полей нет никакой пользы, только вред
$result = $db->query("SELECT * FROM articles ORDER BY ".$db->quote($sortOrder));

// правильно
$allowedSortFields = array('createDate', 'publishDate', 'title');
$defaultSort = 'createDate';
...
if (!in_array($sortOrder, $allowedSortFields)) {
  $sortOrder = $defaultSort;
}
$result = $db->query("SELECT * FROM articles ORDER BY $sortOrder");
```

Ссылки:

1. [Habrahabr: Защита от SQL-инъекций в PHP и MySQL](http://habrahabr.ru/post/148701/)
2. [PHP: PDO — Manual](http://php.net/manual/en/book.pdo.php)
3. [OWASP: SQL Injection](https://www.owasp.org/index.php/SQL_Injection)
4. [Yii DAO: binding parameters](http://www.yiiframework.com/doc/guide/1.1/en/database.dao#binding-parameters) [[ru]](http://www.yiiframework.com/doc/guide/1.1/ru/database.dao#binding-parameters)

###Магические строки и числа
Вынесение магических строк и чисел улучшает код программы сразу в нескольких аспектах: уменьшается количество скопированного кода (принцип KISS), уменьшается вероятность опечаток, которые не сможет отловить интерпретатор PHP, код становится намного легче тестировать. При внесении изменений в константы или строки ошибок их достаточно отредактировать в одном месте.

При этом нужно хорошо осознавать, какие параметры и константы в какое место проекта выносить.

####*Настройки проекта*
Информация, специфическая для проекта должна выноситься в конфиг приложения. Это могут быть настройки путей к директориям, ключи сторонних сервисов (Google Maps), значения любых настроек сайта по умолчанию (размеры изображений-превью, e-mail администратора и т.д.).

```php
// неправильно:
exec("mysqldump --user=abc —-password=Wow!IHaveAPassword abc_db > /backup/backup.sql");

// правильно:
$cfg = MyApp::getConfig();
$dbName     = $cfg['db']['database'];
$dbUser     = $cfg['db']['user'];
$dbPassword = $cfg['db']['password'];
$backupPath = $cfg['path']['backup'];
exec("mysqldump --user=$dbUser —-password=$dbPassword $dbName > {$backupPath}backup.sql");
```

####*Константы класса*
Сообщения об ошибках валидации, сообщения в бросаемых исключениях, специальные строки или числа, имеющие отношение к классу, должны выноситься в константы уровня класса.

```php
// неправильно:
function getListOfObjects($limit)
{
	if ($limit < 0)
		throw new Exception('Число объектов не может быть отрицательным!');
}

// правильно:
const ERROR_LIMIT_CANNOT_BE_NEGATIVE = 'Число объектов не может быть отрицательным!';
. . .
	if ($limit < 0)
		throw new Exception(self::ERROR_LIMIT_CANNOT_BE_NEGATIVE);

// неправильно:
function formatTime($seconds)
{
	if ($seconds >= 3600)
		return gmdate('H:i:s', $seconds);
	else
		return gmdate('i:s', $seconds);
}

// правильно: магические переменные вынесены за пределы функции в константы класса.
const FORMAT_SECONDS_IN_HOUR = 3600;
const FORMAT_PERIOD_ABOVE_HOUR = 'H:i:s';
const FORMAT_PERIOD_BELOW_HOUR = 'H:i';

function formatTimePeriod($seconds)
{
	$format = ($seconds >= self::SECONDS_IN_HOUR)
		? self::FORMAT_PERIOD_ABOVE_HOUR
		: self::FORMAT_PERIOD_BELOW_HOUR

	return gmdate($format, $seconds);
}

// При этом в зависимости от поставленной задачи и этот вариант может оказаться неудачным:
// например, если нужно гибко управлять отображением временных периодов, то эти переменные
// могут быть вынесены в настройки проекта:
$config['app']['timeFormat']['threshold'] = 3600;
$config['app']['timeFormat']['short']     = 'H:i';
$config['app']['timeFormat']['long']      = 'H:i:s';

// Стоит обратить внимание, что здесь используются другие имена:
// threshold уже означает не 'число секунд в одном часе',
// а играет роль разделителя между коротким и длинным форматом вывода времени.
// Таким образом, можно более гибко управлять поведением проекта без заглядывания в код

. . .

function formatTimePeriod($seconds)
{
	$cfg = MyApp::getConfig();

	$format = ($seconds >= $cfg['timeFormat']['threshold'])
		? $cfg['timeFormat']['long']
		: $cfg['timeFormat']['short']

	return gmdate($format, $seconds);
}
```

####*Статические ID в SQL запросах*
Нельзя использовать статические ID для получения записей из БД

```php
// неправильно:
if ($user->id == 1) {
	// If administrator
	. . .
}

// правильно:
if ($user->role == App::ROLE_ADMINISTRATOR) {
	// If administrator
	. . .
}
```

####*Использование baseUrl*
Нельзя полагаться на то, что проект будет привязан к определенному домену, или даже будет находиться в корневой директории вебсервера. Проект должен работать одинаково корректно как на рабочей машине, так и в любом каталоге веб-сервера заказчика. Для достижения этого нужно следить за правильной настройкой путей, во всех гиперссылках, action-атрибутах форм, в JavaScript при редиректах, window.open() и т.д.

```php
// Неправильно: hardcoded домен и url на сайте
<a href="http://mydomain.com/post/43">BlogPost</a>

// Лучше, но задан абсолютный путь на сайте
<a href="/post/43">Blog Post</a>

// Еще лучше, используется настройка проекта baseUrl.
// Если проект находится в корне сервера, то baseUrl хранит пустое значение
<a href="<?php echo $baseUrl;?>/post/43">Blog Post</a>

// В Yii это выглядит следующим образом
<a href="<?php echo Yii::app()->request->baseUrl;?>/post/43">Blog Post</a>

// Самый лучший вариант, нет зависимости не только от домена и baseUrl, но и от самого url
// Код зависит только от конкретного контроллера и экшена
<?php echo CHtml::link('Blog Post', array('post/show', 'id'=>43)); ?>

```

###MVC




Ссылки:
[Best MVC Practices](http://www.yiiframework.com/doc/guide/1.1/en/basics.best-practices)[[ru]](http://www.yiiframework.com/doc/guide/1.1/ru/basics.best-practices)

###Общие принципы проектирования и конструирования хорошего кода

####*Keep It Simple, Stupid*
Стоит стремиться решать задачи наиболее простым возможным способом. Не нужно строить сложные иерархии наследований, взаимодействий и скрытых вызовов. Простые задачи должны решаться просто, сложные – как можно более просто.


####*Don't Repeat Yourself*
Следование принципам DRY означает, что при создании системы нужно стараться избегать повторения информации любого вида – кода, данных, бизнес-логики, документации. Четкая формулировка: “Любая часть знаний о системе должна иметь единственное, однозначное и надежное представление в системе.”.
В самом простом виде это означает запрет копипаста; любой повторяющийся участок кода должен быть вынесен в функцию. Однако принцип DRY должен соблюдаться и на более высоких уровнях абстракции: не должно быть классов, методов или модулей, отвечающих за выполнение одинаковых или пересекающихся задач. То же самое касается сторонних модулей или плагинов: в системе должна быть только одна сущность, отвечающая за то или иное действие.

####*You Ain't Gonna Need It*

Ссылки:

1. [Habrahabr: Три ключевых принципа ПО, которые вы должны понимать](http://habrahabr.ru/post/144611/)
2. [Zen Of Python](http://ru.wikipedia.org/wiki/Python#.D0.A4.D0.B8.D0.BB.D0.BE.D1.81.D0.BE.D1.84.D0.B8.D1.8F)
3. [Wikipedia: DRY](http://ru.wikipedia.org/wiki/Don't_repeat_yourself)




##Список литературы на лето для общего развития

1. [PHP: The Right Way](http://www.phptherightway.com/) Общие рекомендации, как правильно писать на PHP, полезные ссылки и обсуждения
2. [Patterns, UML and Refactoring](http://sourcemaking.com/) Паттерны, антипаттерны, примеры использования, в т.ч. на PHP
3. The Definitive Guide to Yii [версия на русском] Обязательное чтение для программистов Yii, хорошо структурированный документ, позволяющий восполнить пробелы во всех аспектах использования фреймворка
